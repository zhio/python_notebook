# 事务

## 概念

事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部不成功。

## 特性

事务有四个特性，ACID

### 原子性（**Atomicity**）

事务作为一个整体执行，要么全部成功，要么全部失败。

示例:

假设银行存钱转账操作

```python
1、从A账号中把余额读出来（500）。
2、对A账号做减法操作（500-100）。
3、把结果写回A账号中（400）。
4、从B账号中把余额读出来（500）。
5、对B账号做加法操作（500+100）。
6、把结果写回B账号中（600）。
```

原子性保证 1-6部必须全部执行，要么全部不执行，假设在第5步失败了，则全部失败，执行回滚操作。

### 一致性（Consistency）

事务应该确保从一个一致性状态变为另一个一致性状态，保证数据的完整性

A和B的转账操作，不管怎么转，总和1000要保证不变。

### 隔离性（Isolation）

多个用户并发操作时，一个事务的执行不能影响其他事务的执行，事务之间是隔离的。

比如在A给B转账时，只要事务没有提交，查询A和B账号的时候，两个账户依旧不变。

### 持久性（Durability）

事务一旦提交，对于数据库的修改应该是永久的。

A和B转完账之后，即事务提交后，A一定是400，B一定是600

## 事务并发问题

### 脏读

脏读就是读到了其他事务未提交的数据。比如事务A修改了一个数据，但是没有提交事务，这时事务B读取到的是事务A修改的数据，这个数据就是脏读。

### 可重复读

可重复读指的是在一个事务内，最开始读的数据和事务结束之前读到的数据都是一致的。

### 不可重复读

一个事务读到另一个事务修改后并提交的数据。在同一个事务中，对于同一组数据读取到的内容结果不一致。比如，事务B 在 事务A 提交前读到的结果，和在 事务A 提交后读到的结果可能不同。

### 幻读

幻读是针对insert操作来说的，指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。

## 事务隔离级别

SQL标准定义了四种隔离级别。

### 读未提交

最低隔离级别，无法保证以上的问题，会有脏读的问题

### 读已提交

可以避免脏读的问题，但是避免不了可重复读和幻读的问题

### 可重复读

mysql默认的隔离级别，保证了在同一事务中多次读取同样数据结果一致。但是无法解决幻读的问题。

### 串行化

最高的隔离级别，解决了上述问题，但是性能最差。

## 如何解决幻读

mysql使用MVCC+Next-key来避免幻读。

### MVCC

mysql把每个操作都定义成一个事务，每开启一个事务，系统的事务版本号自动递增。每行记录都有两个隐藏列：创建版本号和删除版本号。

- select

  InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的，在事务开始之后才插入的行，事务不会看到。

  行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除，在事务开始之前就已经过期的数据行，该事务也不会看到。

- insert

  将当前系统版本号作为数据行快照的创建版本号

- update

  将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

  保存这两个版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且能保证只会读取到复合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。

- delete

  将当前系统版本号作为数据行快照的删除版本号。

### Next-key

Next-Key-locks是行锁和GAP（间隙锁）的合并;

**行锁**可以防止不同事务版本的数据修改提交时造成数据冲突的情况。

**间隙锁**该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 READ COMMITTED 或者配置 **innodb_locks_unsafe_for_binlog** 参数为 ON 。

